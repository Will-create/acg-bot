import { Hooks } from './hooks';
import { ServerData } from './data';
import { ErrorOptions } from './error/index';
import { LoaderOptions } from './loader/index';
/**
 * Represents the states of the chart.
 */
export declare enum ChartState {
    Initializing = "initializing",
    Loading = "loading",
    Error = "error",
    Show = "show",
    Destroyed = "destroyed"
}
/**
 * Represents the chartisan options.
 */
export interface ChartisanOptions<D> extends Omit<UpdateOptions, 'background' | 'additional'> {
    /**
     * Determines the DOM element element to
     * attach the chart to.
     */
    el?: string | Element | null;
    /**
     * Determines the options of the loader.
     */
    loader?: LoaderOptions;
    /**
     * Determine the error options.
     */
    error?: ErrorOptions;
    /**
     * Hooks that run before the render happens and that are
     * used to transform the data after the library has done
     * it's job.
     */
    hooks?: Hooks<D>;
}
/**
 * Interface that denotes a class value.
 */
export interface isChartisan<D> {
    new (options: ChartisanOptions<D>): Chartisan<D>;
}
/**
 * Options to update the chart.
 */
export interface UpdateOptions<U = {}> {
    /**
     * Determines the request url.
     * Replaces the old one.
     */
    url?: string;
    /**
     * Determines the options of the request.
     * Replaces the old one.
     */
    options?: RequestInit;
    /**
     * Determines the data of the chart.
     * If set, no request will be performed as it
     * will be static data. If a function is provided,
     * the chart will display a loading message while
     * it resolves the data.
     */
    data?: ServerData | (() => ServerData);
    /**
     * Loads the data in the chart in the background,
     * without any visual feedback to the user, this is
     * used to perform updates without displaying the
     * "Loading chart" text and therefore, without re-creating
     * the chart.
     */
    background?: boolean;
    /**
     * Store the additional options for the update function.
     */
    additional?: U;
}
/**
 * Chartisan class
 */
export declare abstract class Chartisan<D> {
    /**
     * Stores the chartisan options. The options
     * assigned here are the defaults and can be
     * overwritten given the constructor options.
     */
    protected options: ChartisanOptions<D>;
    /**
     * Represents the DOM element to attach the chart to.
     */
    protected element: Element;
    /**
     * Stores the HTML element that takes the control
     * of the chart. It's always a child of element
     */
    protected controller: HTMLDivElement;
    /**
     * State of the chart.
     */
    protected cstate: ChartState;
    /**
     * Represents the body where the chart is located.
     */
    protected body: HTMLDivElement;
    /**
     * Represents the modal to show when loading
     * or showing a chart error.
     */
    protected modal: HTMLDivElement;
    /**
     * Creates an instance of Chartisan.
     */
    constructor(options?: ChartisanOptions<D>);
    /**
     * Set he modal settings.
     */
    private setModal;
    /**
     * Changes the status of the chart.
     */
    protected changeTo(state: ChartState, err?: Error): void;
    /**
     * Bootstraps the chart.
     */
    protected bootstrap(): void;
    /**
     * Requests the data to the server.
     */
    protected request<U>(options?: UpdateOptions<U>): void;
    /**
     * Attaches the refresh event handler to the icon.
     */
    protected refreshEvent(): void;
    /**
     * Refresh the chart with new information.
     */
    update<U>(options?: UpdateOptions<U>): void;
    /**
     * Destroys the chart instance and removes
     * the controller node from the DOM.
     */
    destroy(): void;
    /**
     * Gets the data from a given request, applying
     * the hooks of the chart.
     */
    protected getDataFrom(server: ServerData): D;
    /**
     * Called when the data is correctly recieved from
     * the server. This method calls onUpdate() internally.
     */
    protected onRawUpdate<U>(response: JSON, options?: UpdateOptions<U>): void;
    /**
     * Formats the data of the request to match the data that
     * the chart needs (acording to the desired front-end).
     */
    protected abstract formatData(response: ServerData): D;
    /**
     * Handles a successfull response of the chart data.
     */
    protected abstract onUpdate<U>(data: D, options?: U): void;
    /**
     * Called when the chart has to be updated from
     * the background, without creating a new chart instance.
     */
    protected abstract onBackgroundUpdate<U>(data: D, options?: U): void;
    /**
     * Handles a successful destroy call.
     */
    protected abstract onDestroy(): void;
    /**
     * Handles an error when getting the data of the chart.
     */
    protected onError(err: Error): void;
    /**
     * Returns the current chart state.
     */
    state(): ChartState;
}
