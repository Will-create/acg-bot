{"version":3,"file":"chartisan_chartjs.js","sources":["../src/hooks.ts","../src/index.ts"],"sourcesContent":["import { colorPalette, Hooks as BaseHooks } from '@chartisan/chartisan'\nimport {\n  ChartType,\n  Scriptable,\n  ChartColor,\n  ChartDataSets,\n  ChartTitleOptions,\n  ChartLegendOptions,\n  ChartTooltipOptions,\n  ChartAnimationOptions,\n  ChartLayoutPaddingObject,\n} from 'chart.js'\nimport { CC } from './index'\n\n/**\n * Used as the interface for the types hook.\n */\nexport interface DatasetHook extends ChartDataSets {\n  type: ChartType | string\n}\n\nexport class Hooks extends BaseHooks<CC> {\n  /**\n   * Used to set the color color of a dataset.\n   */\n  colors(colors: (ChartColor | ChartColor[] | Scriptable<ChartColor>)[] = colorPalette): this {\n    return this.custom(({ data }) => {\n      if (data.data?.datasets)\n        data.data.datasets = data.data.datasets.map((dataset, index) => ({\n          ...dataset,\n          backgroundColor: colors[index % colors.length],\n        }))\n      return data\n    })\n  }\n\n  /**\n   * Set the pie border colors of the datasets.\n   */\n  borderColors(colors: (ChartColor | ChartColor[] | Scriptable<ChartColor>)[] = colorPalette): this {\n    return this.custom(({ data }) => {\n      if (data.data?.datasets)\n        data.data.datasets = data.data.datasets.map((dataset, index) => ({\n          ...dataset,\n          borderColor: colors[index % colors.length],\n        }))\n      return data\n    })\n  }\n\n  /**\n   * Set the pie colors of the datasets.\n   */\n  pieColors(colors: ChartColor[] = colorPalette): this {\n    return this.custom(({ data }) => {\n      if (data.data?.datasets) {\n        data.data.datasets = data.data.datasets.map((dataset, _, array) => {\n          const d = new Array(dataset.data?.length ?? array?.length).fill('')\n          return {\n            ...dataset,\n            // borderColor: d.map((_, i) => colors[i % colors.length]),\n            backgroundColor: d.map((_, i) => colors[i % colors.length]),\n          }\n        })\n      }\n      return data\n    })\n  }\n\n  /**\n   * Set the pie border colors of the datasets.\n   */\n  pieBorderColors(colors: ChartColor[] = colorPalette): this {\n    return this.custom(({ data }) => {\n      if (data.data?.datasets) {\n        data.data.datasets = data.data.datasets.map((dataset, _, array) => {\n          const d = new Array(dataset.data?.length ?? array?.length).fill('')\n          return {\n            ...dataset,\n            borderColor: d.map((_, i) => colors[i % colors.length]),\n          }\n        })\n      }\n      return data\n    })\n  }\n\n  /**\n   * Used to make the chart responsive.\n   */\n  responsive(value = true): this {\n    return this.options({ options: { maintainAspectRatio: !value } })\n  }\n\n  /**\n   * Set the chart legend options. If a boolean is\n   * supplied, it will be used as the display value.\n   */\n  legend(legend: boolean | ChartLegendOptions = {}): this {\n    if (typeof legend === 'boolean') legend = { display: legend }\n    return this.options({ options: { legend } })\n  }\n\n  /**\n   * Determines if the chart will show the axes.\n   */\n  displayAxes(display = true, strict = false): this {\n    return this.options(\n      strict\n        ? { options: { scale: { display } } }\n        : {\n            options: {\n              scales: { xAxes: [{ display }], yAxes: [{ display }] },\n            },\n          }\n    )\n  }\n\n  /**\n   * Creates a minimalist chart.\n   */\n  minimalist(value = true): this {\n    this.legend({ display: !value })\n    return this.displayAxes(!value)\n  }\n\n  /**\n   * Determines the padding of the chart.\n   */\n  padding(padding: number | ChartLayoutPaddingObject = 5): this {\n    return this.options({ options: { layout: { padding } } })\n  }\n\n  /**\n   * Set the dataset options. If a single string is provided, all the datasets\n   * will will be specified to the desired type. If an array is provided, if the\n   * inner element is a string, it will be used as a type, otherwise, the options\n   * will be applied, in both cases, to the nth position. Keep in mind that if the\n   * array length is less than the datasets, it will start from the start again.\n   */\n  datasets(types: ChartType | (ChartType | DatasetHook)[], general = 'bar'): this {\n    return this.custom(({ data }) => {\n      data.type = typeof types === 'string' ? types : general\n      if (Array.isArray(types) && data.data?.datasets) {\n        const t = types.map((e) => (typeof e === 'string' ? { type: e } : e))\n        data.data.datasets = data.data.datasets.map((dataset, index) => ({\n          ...dataset,\n          ...t[index % t.length],\n        }))\n      }\n      return data\n    })\n  }\n\n  /**\n   * Sets a title to the chart.\n   */\n  title(title: string | ChartTitleOptions = {}): this {\n    return this.options({\n      options: {\n        title: typeof title === 'string' ? { text: title, display: true } : { display: true, ...title },\n      },\n    })\n  }\n\n  /**\n   * Set the chart to begin at zero.\n   */\n  beginAtZero(beginAtZero = true, axe: 'x' | 'y' = 'y'): this {\n    return this.options({\n      options: { scales: { [`${axe}Axes`]: [{ ticks: { beginAtZero } }] } },\n    })\n  }\n\n  /**\n   * Set the chart to begin at zero.\n   */\n  precision(precision: number, axe: 'x' | 'y' = 'y'): this {\n    return this.options({\n      options: { scales: { [`${axe}Axes`]: [{ ticks: { precision } }] } },\n    })\n  }\n\n  /**\n   * Set the chart to begin at zero.\n   */\n  stepSize(stepSize: number, axe: 'x' | 'y' = 'y'): this {\n    return this.options({\n      options: { scales: { [`${axe}Axes`]: [{ ticks: { stepSize } }] } },\n    })\n  }\n\n  /**\n   * Sets the tooltip options for the chart.\n   */\n  tooltip(tooltips: boolean | ChartTooltipOptions): this {\n    if (typeof tooltips === 'boolean') tooltips = { enabled: tooltips }\n    return this.options({ options: { tooltips } })\n  }\n\n  /**\n   * Sometimes you need a very complex legend. In these cases,\n   * it makes sense to generate an HTML legend. Charts provide\n   * a generateLegend() method on their prototype that returns an\n   * HTML string for the legend. To configure how this legend\n   * is generated, you can change the legendCallback config property.\n   */\n  legendCallback(legendCallback: (chart: Chart) => string): this {\n    return this.options({ options: { legendCallback } })\n  }\n\n  /**\n   * Configures the animations of chart.js.\n   */\n  animation(animation: ChartAnimationOptions): this {\n    return this.options({ options: { animation } })\n  }\n}\n","import { Hooks } from './hooks'\nimport Chart, { ChartConfiguration, ChartUpdateProps } from 'chart.js'\nimport { isHook, ServerData, isChartisan, Chartisan as Base } from '@chartisan/chartisan'\n\nexport { Hooks as ChartisanHooks }\n\n/**\n * Used as an alias.\n */\nexport type CC = ChartConfiguration\n\n/**\n * Base chart class for ChartJS.\n */\nexport class Chartisan extends Base<CC> {\n  /**\n   * The chart canvas.\n   */\n  canvas?: HTMLCanvasElement\n\n  /**\n   * Stores the chart instance.\n   */\n  chart?: Chart\n\n  /**\n   * Helper to mutate an array manually (this is used\n   * because chartjs can only handle animations when the\n   * original array is modified).\n   */\n  static mutateArray<T>(dest: T[], src: T[], action?: (dest: T[], src: T[], index: number) => void) {\n    let i: number\n    for (i = 0; i < src.length; i++) {\n      if (i < dest.length) {\n        if (action) {\n          action(dest, src, i)\n          continue\n        }\n        dest[i] = src[i]\n        continue\n      }\n      dest.push(src[i])\n    }\n    while (i < dest.length) dest.pop()\n  }\n\n  /**\n   * Formats the data of the request to match the data that\n   * the chart needs (acording to the desired front-end).\n   */\n  protected formatData(response: ServerData): CC {\n    return {\n      type: 'bar',\n      data: {\n        labels: response.chart.labels,\n        datasets: response.datasets.map(({ name, values }) => ({\n          label: name,\n          data: values,\n        })),\n      },\n      options: {},\n    }\n  }\n\n  /**\n   * Renews the canvas for another chart to be used.\n   */\n  protected renewCanvas() {\n    if (this.canvas) this.body.removeChild(this.canvas)\n    this.canvas = document.createElement('canvas')\n    this.canvas.style.width = '100%'\n    this.canvas.style.height = '100%'\n    this.body.appendChild(this.canvas)\n  }\n\n  /**\n   * Handles a successfull response of the chart data.\n   */\n  protected onUpdate(data: CC) {\n    if (this.chart) this.chart.destroy()\n    this.renewCanvas()\n    this.chart = new Chart(this.canvas!, data)\n  }\n\n  /**\n   * Handles a successfull response of the chart data\n   * in the background (possibly, updating the values\n   * of the chart without creating a new one).\n   */\n  protected onBackgroundUpdate(data: CC, options?: ChartUpdateProps) {\n    if (this.chart) {\n      // Update the chart options.\n      this.chart.options = {\n        ...this.chart.options,\n        ...data.options,\n      }\n      // Update the labels.\n      if (this.chart.data.labels && data.data?.labels) {\n        Chartisan.mutateArray(this.chart.data.labels, data.data.labels)\n      }\n      // To update the data arrays, it need to be performed\n      // to the original one. If the original one is not modified\n      // no animation will be performed. Therefore, please don't\n      // try beeing smarter here.\n      if (this.chart.data.datasets && data.data?.datasets) {\n        Chartisan.mutateArray(this.chart.data.datasets, data.data.datasets, (dest, src, i) => {\n          Chartisan.mutateArray<(number | number[] | null | undefined) | Chart.ChartPoint>(dest[i].data!, src[i].data!)\n        })\n      }\n      this.chart.update(options)\n    } else this.onUpdate(data)\n  }\n\n  /**\n   * Destroys the chart instance if any.\n   */\n  protected onDestroy() {\n    if (this.chart) this.chart.destroy()\n  }\n\n  /**\n   * This returns a base 64 encoded string of the\n   * chart in it's current state.\n   */\n  toImage(): string | undefined {\n    return this.chart?.toBase64Image()\n  }\n\n  /**\n   * Returns an HTML string of a legend for that chart.\n   * The legend is generated from the legendCallback in the options.\n   */\n  legend(): string | undefined {\n    return (this.chart?.generateLegend() as string) ?? undefined\n  }\n}\n\ndeclare global {\n  /**\n   * Extends the Window interface.\n   */\n  interface Window {\n    /**\n     * The chartisan class to initiate it as a global variable\n     * bound to the window var.\n     */\n    Chartisan: isChartisan<CC>\n\n    /**\n     * Determines the hooks of the chart.\n     */\n    ChartisanHooks: isHook<CC>\n  }\n}\n\nif (typeof window !== 'undefined') {\n  window.Chartisan = Chartisan\n  window.ChartisanHooks = Hooks\n}\n"],"names":["Hooks","colors","colorPalette","custom","data","_data$data","datasets","map","dataset","index","backgroundColor","length","borderColors","_data$data2","borderColor","pieColors","_data$data3","_","array","d","Array","_dataset$data","fill","i","pieBorderColors","_data$data4","_dataset$data2","responsive","value","options","maintainAspectRatio","legend","display","displayAxes","strict","scale","scales","xAxes","yAxes","minimalist","this","padding","layout","types","general","type","isArray","_data$data5","t","e","title","text","beginAtZero","axe","ticks","precision","stepSize","tooltip","tooltips","enabled","legendCallback","animation","BaseHooks","Chartisan","mutateArray","dest","src","action","push","pop","formatData","response","labels","chart","label","name","values","renewCanvas","canvas","body","removeChild","document","createElement","style","width","height","appendChild","onUpdate","destroy","Chart","onBackgroundUpdate","update","onDestroy","toImage","_this$chart","toBase64Image","_this$chart2","generateLegend","undefined","Base","window","ChartisanHooks"],"mappings":"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"}